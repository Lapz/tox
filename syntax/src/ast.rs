
// This file is automatically generated based on the file `./generated.rs.tera` when `hawthorn::generate` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borowed mode, and only
//! this mode has all AST accessors.
#![allow(bad_style, missing_docs, unreachable_pub)]

use crate::traits::{AstNode,self,child_opt,children};
use crate::SyntaxNode;
use SyntaxKind::*;
/// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.
#[derive(Debug,Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
pub enum SyntaxKind {
    // Technical SyntaxKinds: they appear temporally during parsing,
    // but never end up in the final tree
    #[doc(hidden)]
    EOF,
    SEMI, // ; 0
    COMMA, // , 1
    L_PAREN, // ( 2
    R_PAREN, // ) 3
    L_CURLY, // { 4
    R_CURLY, // } 5
    L_BRACK, // [ 6
    R_BRACK, // ] 7
    L_ANGLE, // < 8
    R_ANGLE, // > 9
    AMP, // & 10
    PIPE, // | 11
    PLUS, // + 12
    STAR, // * 13
    SLASH, // / 14
    CARET, // ^ 15
    PERCENT, // % 16
    UNDERSCORE, // _ 17
    EXPONENTIAL, // ^ 18
    DOT, // . 19
    QUESTION, // ? 20
    MINUS, // - 21
    FRETURN, // -> 22
    COLON, // : 23
    COLON_COLON, // :: 24
    EQ, // = 25
    EQEQ, // == 26
    FAT_ARROW, // => 27
    EXCL, // ! 28
    NEQ, // != 29
    LTEQ, // <= 30
    GTEQ, // >= 31
    PLUSEQ, // += 32
    MINUSEQ, // -= 33
    STAREQ, // *= 34
    SLASHEQ, // /= 35
    AMPAMP, // && 36
    PIPEPIPE, // || 37
    CLASS_KW, // class 38
    EXTENDS_KW, // extends 39
    TYPE_KW, // type 40
    AS_KW, // as 41
    MATCH_KW, // match 42
    ENUM_KW, // enum 43
    FN_KW, // fn 44
    LET_KW, // let 45
    IF_KW, // if 46
    ELSE_KW, // else 47
    FOR_KW, // for 48
    WHILE_KW, // while 49
    RETURN_KW, // return 50
    BREAK_KW, // break 51
    CONTINUE_KW, // continue 52
    DO_KW, // do 53
    TRUE_KW, // true 54
    FALSE_KW, // false 55
    OR_KW, // or 56
    AND_KW, // and 57
    EXPORT_KW, // export 58
    IMPORT_KW, // import 59
    FROM_KW, // from 60
    MOD_KW, // mod 61
    NIL_KW, // nil 62
    SELF_KW, // self 63
    INT_NUMBER, // 63
    FLOAT_NUMBER, // 64
    CHAR, // 65
    STRING, // 66
    ERROR, // 67
    IDENT, // 68
    COMMENT, // 69
    WHITESPACE, // 70
    BLOCK, // 71
    SOURCE_FILE, // 72
    CLASS_DEF, // 73
    ENUM_DEF, // 74
    FN_DEF, // 75
    IMPORT_DEF, // 76
    MOD_DEF, // 77
    TYPE_ALIAS_DEF, // 78
    IMPORT_SEGMENT, // 79
    IMPORT_LIST, // 80
    BIND_PAT, // 81
    PLACEHOLDER_PAT, // 82
    TUPLE_PAT, // 83
    LITERAL_PAT, // 84
    TYPE_REF, // 85
    FN_TYPE, // 86
    PAREN_TYPE, // 87
    ARRAY_TYPE, // 88
    IDENT_TYPE, // 89
    RET_TYPE, // 90
    ARRAY_EXPR, // 91
    CALL_EXPR, // 92
    CAST_EXPR, // 93
    INDEX_EXPR, // 94
    FIELD_EXPR, // 95
    BIN_EXPR, // 96
    PREFIX_EXPR, // 97
    TUPLE_EXPR, // 98
    IDENT_EXPR, // 99
    ENUM_EXPR, // 100
    IF_EXPR, // 101
    WHILE_EXPR, // 102
    CONDITION, // 103
    LOOP_EXPR, // 104
    DO_EXPR, // 105
    FOR_EXPR, // 106
    CONTINUE_EXPR, // 107
    BREAK_EXPR, // 108
    BLOCK_EXPR, // 109
    RETURN_EXPR, // 110
    CLOSURE_EXPR, // 111
    PAREN_EXPR, // 112
    MATCH_EXPR, // 113
    MATCH_ARM_LIST, // 114
    MATCH_ARM, // 115
    MATCH_GUARD, // 116
    CLASS_LIT, // 117
    NAMED_FIELD_LIST, // 118
    NAMED_FIELD, // 119
    ENUM_VARIANT, // 120
    NAMED_FIELD_DEF_LIST, // 121
    NAMED_FIELD_DEF, // 122
    RECORD_LITERAL_EXPR, // 123
    ENUM_VARIANT_LIST, // 124
    VISIBILITY, // 125
    LITERAL, // 126
    NAME, // 127
    NAME_REF, // 128
    LET_STMT, // 129
    EXPR_STMT, // 130
    TYPE_PARAM_LIST, // 131
    TYPE_ARG_LIST, // 132
    TYPE_PARAM, // 133
    PARAM_LIST, // 134
    PARAM, // 135
    SELF_PARAM, // 136
    ARG_LIST, // 137
    // Technical kind so that we can cast from u16 safely
    #[doc(hidden)]
    __LAST,
}


impl From<SyntaxKind> for rowan::SyntaxKind {
    fn from(kind: SyntaxKind) -> Self {
        Self(kind as u16)
    }
}


impl SyntaxKind {
    pub fn text(&self) -> &'static str {
        use SyntaxKind::*;
        match self {
            SEMI => ";",
            COMMA => ",",
            L_PAREN => "(",
            R_PAREN => ")",
            L_CURLY => "{",
            R_CURLY => "}",
            L_BRACK => "[",
            R_BRACK => "]",
            L_ANGLE => "<",
            R_ANGLE => ">",
            AMP => "&",
            PIPE => "|",
            PLUS => "+",
            STAR => "*",
            SLASH => "/",
            CARET => "^",
            PERCENT => "%",
            UNDERSCORE => "_",
            EXPONENTIAL => "^",
            DOT => ".",
            QUESTION => "?",
            MINUS => "-",
            FRETURN => "->",
            COLON => ":",
            COLON_COLON => "::",
            EQ => "=",
            EQEQ => "==",
            FAT_ARROW => "=>",
            EXCL => "!",
            NEQ => "!=",
            LTEQ => "<=",
            GTEQ => ">=",
            PLUSEQ => "+=",
            MINUSEQ => "-=",
            STAREQ => "*=",
            SLASHEQ => "/=",
            AMPAMP => "&&",
            PIPEPIPE => "||",
            CLASS_KW => "class",
            EXTENDS_KW => "extends",
            TYPE_KW => "type",
            AS_KW => "as",
            MATCH_KW => "match",
            ENUM_KW => "enum",
            FN_KW => "fn",
            LET_KW => "let",
            IF_KW => "if",
            ELSE_KW => "else",
            FOR_KW => "for",
            WHILE_KW => "while",
            RETURN_KW => "return",
            BREAK_KW => "break",
            CONTINUE_KW => "continue",
            DO_KW => "do",
            TRUE_KW => "true",
            FALSE_KW => "false",
            OR_KW => "or",
            AND_KW => "and",
            EXPORT_KW => "export",
            IMPORT_KW => "import",
            FROM_KW => "from",
            MOD_KW => "mod",
            NIL_KW => "nil",
            SELF_KW => "self",
            INT_NUMBER => "INT_NUMBER",
            FLOAT_NUMBER => "FLOAT_NUMBER",
            CHAR => "CHAR",
            STRING => "STRING",
            ERROR => "ERROR",
            IDENT => "IDENT",
            COMMENT => "COMMENT",
            WHITESPACE => "WHITESPACE",
            BLOCK => "BLOCK",
            SOURCE_FILE => "SOURCE_FILE",
            CLASS_DEF => "CLASS_DEF",
            ENUM_DEF => "ENUM_DEF",
            FN_DEF => "FN_DEF",
            IMPORT_DEF => "IMPORT_DEF",
            MOD_DEF => "MOD_DEF",
            TYPE_ALIAS_DEF => "TYPE_ALIAS_DEF",
            IMPORT_SEGMENT => "IMPORT_SEGMENT",
            IMPORT_LIST => "IMPORT_LIST",
            BIND_PAT => "BIND_PAT",
            PLACEHOLDER_PAT => "PLACEHOLDER_PAT",
            TUPLE_PAT => "TUPLE_PAT",
            LITERAL_PAT => "LITERAL_PAT",
            TYPE_REF => "TYPE_REF",
            FN_TYPE => "FN_TYPE",
            PAREN_TYPE => "PAREN_TYPE",
            ARRAY_TYPE => "ARRAY_TYPE",
            IDENT_TYPE => "IDENT_TYPE",
            RET_TYPE => "RET_TYPE",
            ARRAY_EXPR => "ARRAY_EXPR",
            CALL_EXPR => "CALL_EXPR",
            CAST_EXPR => "CAST_EXPR",
            INDEX_EXPR => "INDEX_EXPR",
            FIELD_EXPR => "FIELD_EXPR",
            BIN_EXPR => "BIN_EXPR",
            PREFIX_EXPR => "PREFIX_EXPR",
            TUPLE_EXPR => "TUPLE_EXPR",
            IDENT_EXPR => "IDENT_EXPR",
            ENUM_EXPR => "ENUM_EXPR",
            IF_EXPR => "IF_EXPR",
            WHILE_EXPR => "WHILE_EXPR",
            CONDITION => "CONDITION",
            LOOP_EXPR => "LOOP_EXPR",
            DO_EXPR => "DO_EXPR",
            FOR_EXPR => "FOR_EXPR",
            CONTINUE_EXPR => "CONTINUE_EXPR",
            BREAK_EXPR => "BREAK_EXPR",
            BLOCK_EXPR => "BLOCK_EXPR",
            RETURN_EXPR => "RETURN_EXPR",
            CLOSURE_EXPR => "CLOSURE_EXPR",
            PAREN_EXPR => "PAREN_EXPR",
            MATCH_EXPR => "MATCH_EXPR",
            MATCH_ARM_LIST => "MATCH_ARM_LIST",
            MATCH_ARM => "MATCH_ARM",
            MATCH_GUARD => "MATCH_GUARD",
            CLASS_LIT => "CLASS_LIT",
            NAMED_FIELD_LIST => "NAMED_FIELD_LIST",
            NAMED_FIELD => "NAMED_FIELD",
            ENUM_VARIANT => "ENUM_VARIANT",
            NAMED_FIELD_DEF_LIST => "NAMED_FIELD_DEF_LIST",
            NAMED_FIELD_DEF => "NAMED_FIELD_DEF",
            RECORD_LITERAL_EXPR => "RECORD_LITERAL_EXPR",
            ENUM_VARIANT_LIST => "ENUM_VARIANT_LIST",
            VISIBILITY => "VISIBILITY",
            LITERAL => "LITERAL",
            NAME => "NAME",
            NAME_REF => "NAME_REF",
            LET_STMT => "LET_STMT",
            EXPR_STMT => "EXPR_STMT",
            TYPE_PARAM_LIST => "TYPE_PARAM_LIST",
            TYPE_ARG_LIST => "TYPE_ARG_LIST",
            TYPE_PARAM => "TYPE_PARAM",
            PARAM_LIST => "PARAM_LIST",
            PARAM => "PARAM",
            SELF_PARAM => "SELF_PARAM",
            ARG_LIST => "ARG_LIST",
        
            _ => ""
        }
    }

    pub fn is_trivia(&self) -> bool {
        use SyntaxKind::*;
        match self {
            COMMENT | WHITESPACE => true,
            _ => false,
        }
    }
}


// ArgList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArgList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARG_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArgList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArgList {
    pub fn args(&self) -> impl Iterator<Item = Expr> {
        children(self)
    }
}

// ArrayExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArrayExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARRAY_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArrayExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArrayExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        children(self)
    }
}

// ArrayType

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArrayType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARRAY_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArrayType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArrayType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// BinExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BinExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BIN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BinExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BinExpr {}

// BindPat

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BindPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BindPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BIND_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BindPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for BindPat {}
impl BindPat {}

// Block

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Block {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BLOCK => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Block { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Block {
    pub fn statements(&self) -> impl Iterator<Item = Stmt> {
        children(self)
    }
}

// BlockExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BlockExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BLOCK_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BlockExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BlockExpr {
    pub fn block(&self) -> Option<Block> {
        child_opt(self)
    }
}

// BreakExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BreakExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BREAK_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BreakExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BreakExpr {}

// CallExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for CallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CALL_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(CallExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::ArgListOwner for CallExpr {}
impl CallExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// CastExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for CastExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CAST_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(CastExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl CastExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// ClassDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ClassDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CLASS_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ClassDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for ClassDef {}
impl traits::TypeParamsOwner for ClassDef {}
impl traits::FnDefOwner for ClassDef {}
impl traits::NamedFieldsOwner for ClassDef {}
impl traits::VisibilityOwner for ClassDef {}
impl ClassDef {}

// ClosureExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClosureExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ClosureExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CLOSURE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ClosureExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::ArgListOwner for ClosureExpr {}
impl ClosureExpr {
    pub fn param_list(&self) -> Option<ParamList> {
        child_opt(self)
    }

    pub fn body(&self) -> Option<BlockExpr> {
        child_opt(self)
    }

    pub fn ret_type(&self) -> Option<RetType> {
        child_opt(self)
    }
}

// Condition

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Condition {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Condition {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CONDITION => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Condition { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Condition {
    pub fn pat(&self) -> Option<Pat> {
        child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// ContinueExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ContinueExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CONTINUE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ContinueExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ContinueExpr {}

// EnumDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for EnumDef {}
impl traits::VisibilityOwner for EnumDef {}
impl traits::TypeParamsOwner for EnumDef {}
impl EnumDef {
    pub fn variant_list(&self) -> Option<EnumVariantList> {
        child_opt(self)
    }
}

// EnumExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl EnumExpr {
    pub fn segments(&self) -> impl Iterator<Item = IdentExpr> {
        children(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// EnumVariant

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariant {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumVariant {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_VARIANT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumVariant { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for EnumVariant {}
impl EnumVariant {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// EnumVariantList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumVariantList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_VARIANT_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumVariantList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl EnumVariantList {
    pub fn variants(&self) -> impl Iterator<Item = EnumVariant> {
        children(self)
    }
}

// Expr


    #[derive(Debug, Clone, PartialEq, Eq,Hash)]
    pub enum Expr {
            ArrayExpr(ArrayExpr),
            IdentExpr(IdentExpr),
            ParenExpr(ParenExpr),
            ClosureExpr(ClosureExpr),
            IfExpr(IfExpr),
            ForExpr(ForExpr),
            WhileExpr(WhileExpr),
            ContinueExpr(ContinueExpr),
            BreakExpr(BreakExpr),
            BlockExpr(BlockExpr),
            ReturnExpr(ReturnExpr),
            MatchExpr(MatchExpr),
            RecordLiteralExpr(RecordLiteralExpr),
            CallExpr(CallExpr),
            IndexExpr(IndexExpr),
            FieldExpr(FieldExpr),
            CastExpr(CastExpr),
            PrefixExpr(PrefixExpr),
            BinExpr(BinExpr),
            Literal(Literal),
            TupleExpr(TupleExpr),
            EnumExpr(EnumExpr),
    }
        impl From<ArrayExpr> for Expr {
            fn from(n: ArrayExpr) -> Expr { 
                Expr::ArrayExpr(n)
            }
        }
        impl From<IdentExpr> for Expr {
            fn from(n: IdentExpr) -> Expr { 
                Expr::IdentExpr(n)
            }
        }
        impl From<ParenExpr> for Expr {
            fn from(n: ParenExpr) -> Expr { 
                Expr::ParenExpr(n)
            }
        }
        impl From<ClosureExpr> for Expr {
            fn from(n: ClosureExpr) -> Expr { 
                Expr::ClosureExpr(n)
            }
        }
        impl From<IfExpr> for Expr {
            fn from(n: IfExpr) -> Expr { 
                Expr::IfExpr(n)
            }
        }
        impl From<ForExpr> for Expr {
            fn from(n: ForExpr) -> Expr { 
                Expr::ForExpr(n)
            }
        }
        impl From<WhileExpr> for Expr {
            fn from(n: WhileExpr) -> Expr { 
                Expr::WhileExpr(n)
            }
        }
        impl From<ContinueExpr> for Expr {
            fn from(n: ContinueExpr) -> Expr { 
                Expr::ContinueExpr(n)
            }
        }
        impl From<BreakExpr> for Expr {
            fn from(n: BreakExpr) -> Expr { 
                Expr::BreakExpr(n)
            }
        }
        impl From<BlockExpr> for Expr {
            fn from(n: BlockExpr) -> Expr { 
                Expr::BlockExpr(n)
            }
        }
        impl From<ReturnExpr> for Expr {
            fn from(n: ReturnExpr) -> Expr { 
                Expr::ReturnExpr(n)
            }
        }
        impl From<MatchExpr> for Expr {
            fn from(n: MatchExpr) -> Expr { 
                Expr::MatchExpr(n)
            }
        }
        impl From<RecordLiteralExpr> for Expr {
            fn from(n: RecordLiteralExpr) -> Expr { 
                Expr::RecordLiteralExpr(n)
            }
        }
        impl From<CallExpr> for Expr {
            fn from(n: CallExpr) -> Expr { 
                Expr::CallExpr(n)
            }
        }
        impl From<IndexExpr> for Expr {
            fn from(n: IndexExpr) -> Expr { 
                Expr::IndexExpr(n)
            }
        }
        impl From<FieldExpr> for Expr {
            fn from(n: FieldExpr) -> Expr { 
                Expr::FieldExpr(n)
            }
        }
        impl From<CastExpr> for Expr {
            fn from(n: CastExpr) -> Expr { 
                Expr::CastExpr(n)
            }
        }
        impl From<PrefixExpr> for Expr {
            fn from(n: PrefixExpr) -> Expr { 
                Expr::PrefixExpr(n)
            }
        }
        impl From<BinExpr> for Expr {
            fn from(n: BinExpr) -> Expr { 
                Expr::BinExpr(n)
            }
        }
        impl From<Literal> for Expr {
            fn from(n: Literal) -> Expr { 
                Expr::Literal(n)
            }
        }
        impl From<TupleExpr> for Expr {
            fn from(n: TupleExpr) -> Expr { 
                Expr::TupleExpr(n)
            }
        }
        impl From<EnumExpr> for Expr {
            fn from(n: EnumExpr) -> Expr { 
                Expr::EnumExpr(n)
            }
        }
impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | ARRAY_EXPR | IDENT_EXPR | PAREN_EXPR | CLOSURE_EXPR | IF_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | RECORD_LITERAL_EXPR | CALL_EXPR | INDEX_EXPR | FIELD_EXPR | CAST_EXPR | PREFIX_EXPR | BIN_EXPR | LITERAL | TUPLE_EXPR | ENUM_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
             
            | ARRAY_EXPR  => Some(Expr::ArrayExpr(ArrayExpr {syntax})), 
            | IDENT_EXPR  => Some(Expr::IdentExpr(IdentExpr {syntax})), 
            | PAREN_EXPR  => Some(Expr::ParenExpr(ParenExpr {syntax})), 
            | CLOSURE_EXPR  => Some(Expr::ClosureExpr(ClosureExpr {syntax})), 
            | IF_EXPR  => Some(Expr::IfExpr(IfExpr {syntax})), 
            | FOR_EXPR  => Some(Expr::ForExpr(ForExpr {syntax})), 
            | WHILE_EXPR  => Some(Expr::WhileExpr(WhileExpr {syntax})), 
            | CONTINUE_EXPR  => Some(Expr::ContinueExpr(ContinueExpr {syntax})), 
            | BREAK_EXPR  => Some(Expr::BreakExpr(BreakExpr {syntax})), 
            | BLOCK_EXPR  => Some(Expr::BlockExpr(BlockExpr {syntax})), 
            | RETURN_EXPR  => Some(Expr::ReturnExpr(ReturnExpr {syntax})), 
            | MATCH_EXPR  => Some(Expr::MatchExpr(MatchExpr {syntax})), 
            | RECORD_LITERAL_EXPR  => Some(Expr::RecordLiteralExpr(RecordLiteralExpr {syntax})), 
            | CALL_EXPR  => Some(Expr::CallExpr(CallExpr {syntax})), 
            | INDEX_EXPR  => Some(Expr::IndexExpr(IndexExpr {syntax})), 
            | FIELD_EXPR  => Some(Expr::FieldExpr(FieldExpr {syntax})), 
            | CAST_EXPR  => Some(Expr::CastExpr(CastExpr {syntax})), 
            | PREFIX_EXPR  => Some(Expr::PrefixExpr(PrefixExpr {syntax})), 
            | BIN_EXPR  => Some(Expr::BinExpr(BinExpr {syntax})), 
            | LITERAL  => Some(Expr::Literal(Literal {syntax})), 
            | TUPLE_EXPR  => Some(Expr::TupleExpr(TupleExpr {syntax})), 
            | ENUM_EXPR  => Some(Expr::EnumExpr(EnumExpr {syntax})),_ => None
        }
    }
    fn syntax(&self) -> &SyntaxNode {  
        match self {
             
                Expr::ArrayExpr(kind)  => &kind.syntax, 
                Expr::IdentExpr(kind)  => &kind.syntax, 
                Expr::ParenExpr(kind)  => &kind.syntax, 
                Expr::ClosureExpr(kind)  => &kind.syntax, 
                Expr::IfExpr(kind)  => &kind.syntax, 
                Expr::ForExpr(kind)  => &kind.syntax, 
                Expr::WhileExpr(kind)  => &kind.syntax, 
                Expr::ContinueExpr(kind)  => &kind.syntax, 
                Expr::BreakExpr(kind)  => &kind.syntax, 
                Expr::BlockExpr(kind)  => &kind.syntax, 
                Expr::ReturnExpr(kind)  => &kind.syntax, 
                Expr::MatchExpr(kind)  => &kind.syntax, 
                Expr::RecordLiteralExpr(kind)  => &kind.syntax, 
                Expr::CallExpr(kind)  => &kind.syntax, 
                Expr::IndexExpr(kind)  => &kind.syntax, 
                Expr::FieldExpr(kind)  => &kind.syntax, 
                Expr::CastExpr(kind)  => &kind.syntax, 
                Expr::PrefixExpr(kind)  => &kind.syntax, 
                Expr::BinExpr(kind)  => &kind.syntax, 
                Expr::Literal(kind)  => &kind.syntax, 
                Expr::TupleExpr(kind)  => &kind.syntax, 
                Expr::EnumExpr(kind)  => &kind.syntax,}
    
    }
}

impl Expr {}

// ExprStmt

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ExprStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            EXPR_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ExprStmt { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ExprStmt {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// FieldExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FieldExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FIELD_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FieldExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl FieldExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        children(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn name(&self) -> Option<Name> {
        child_opt(self)
    }
}

// FnDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FnDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FN_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FnDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for FnDef {}
impl traits::TypeParamsOwner for FnDef {}
impl traits::VisibilityOwner for FnDef {}
impl FnDef {
    pub fn param_list(&self) -> Option<ParamList> {
        child_opt(self)
    }

    pub fn body(&self) -> Option<BlockExpr> {
        child_opt(self)
    }

    pub fn ret_type(&self) -> Option<RetType> {
        child_opt(self)
    }
}

// FnType

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FnType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FN_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FnType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypesOwner for FnType {}
impl FnType {
    pub fn param_list(&self) -> Option<ParamList> {
        child_opt(self)
    }

    pub fn ret_type(&self) -> Option<RetType> {
        child_opt(self)
    }
}

// ForExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ForExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FOR_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ForExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::LoopBodyOwner for ForExpr {}
impl ForExpr {}

// IdentExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IdentExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IDENT_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IdentExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for IdentExpr {}
impl IdentExpr {}

// IdentType

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IdentType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IDENT_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IdentType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IdentType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }

    pub fn type_args(&self) -> Option<TypeArgList> {
        child_opt(self)
    }
}

// IfExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IfExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IF_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IfExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IfExpr {
    pub fn condition(&self) -> Option<Condition> {
        child_opt(self)
    }
}

// ImportDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ImportDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IMPORT_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ImportDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::ImportSegmentOwner for ImportDef {}
impl ImportDef {
    pub fn imports(&self) -> Option<ImportSegment> {
        child_opt(self)
    }

    pub fn import_list(&self) -> Option<ImportList> {
        child_opt(self)
    }
}

// ImportList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ImportList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IMPORT_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ImportList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::ImportSegmentOwner for ImportList {}
impl ImportList {
    pub fn segments(&self) -> impl Iterator<Item = ImportSegment> {
        children(self)
    }
}

// ImportSegment

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportSegment {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ImportSegment {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IMPORT_SEGMENT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ImportSegment { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ImportSegment {
    pub fn name(&self) -> Option<Name> {
        child_opt(self)
    }
}

// IndexExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IndexExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            INDEX_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IndexExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IndexExpr {}

// LetStmt

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LetStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LET_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LetStmt { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypeAscriptionOwner for LetStmt {}
impl LetStmt {
    pub fn pat(&self) -> Option<Pat> {
        child_opt(self)
    }

    pub fn initializer(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// Literal

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LITERAL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Literal { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Literal {}

// LiteralPat

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LiteralPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LITERAL_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LiteralPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl LiteralPat {
    pub fn literal(&self) -> Option<Literal> {
        child_opt(self)
    }
}

// MatchArm

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_ARM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchArm { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchArm {
    pub fn pats(&self) -> impl Iterator<Item = Pat> {
        children(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// MatchArmList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArmList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchArmList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_ARM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchArmList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchArmList {
    pub fn arms(&self) -> impl Iterator<Item = MatchArm> {
        children(self)
    }
}

// MatchExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn match_arm_list(&self) -> Option<MatchArmList> {
        child_opt(self)
    }
}

// ModDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ModDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MOD_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ModDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for ModDef {}
impl ModDef {}

// Name

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAME => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Name { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Name {}

// NameRef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NameRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAME_REF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NameRef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NameRef {}

// NamedField

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedField {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedField {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedField { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedField {
    pub fn name(&self) -> Option<Name> {
        child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// NamedFieldDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for NamedFieldDef {}
impl traits::TypeAscriptionOwner for NamedFieldDef {}
impl NamedFieldDef {}

// NamedFieldDefList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldDefList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldDefList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_DEF_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldDefList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedFieldDefList {
    pub fn fields(&self) -> impl Iterator<Item = NamedFieldDef> {
        children(self)
    }
}

// NamedFieldList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedFieldList {
    pub fn fields(&self) -> impl Iterator<Item = NamedField> {
        children(self)
    }
}

// Param

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Param {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PARAM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Param { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypeAscriptionOwner for Param {}
impl Param {
    pub fn pat(&self) -> Option<Pat> {
        child_opt(self)
    }
}

// ParamList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParamList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PARAM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParamList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ParamList {
    pub fn params(&self) -> impl Iterator<Item = Param> {
        children(self)
    }
}

// ParenExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParenExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PAREN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParenExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ParenExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// ParenType

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParenType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PAREN_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParenType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypesOwner for ParenType {}
impl ParenType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// Pat


    #[derive(Debug, Clone, PartialEq, Eq,Hash)]
    pub enum Pat {
            BindPat(BindPat),
            PlaceholderPat(PlaceholderPat),
            TuplePat(TuplePat),
            LiteralPat(LiteralPat),
    }
        impl From<BindPat> for Pat {
            fn from(n: BindPat) -> Pat { 
                Pat::BindPat(n)
            }
        }
        impl From<PlaceholderPat> for Pat {
            fn from(n: PlaceholderPat) -> Pat { 
                Pat::PlaceholderPat(n)
            }
        }
        impl From<TuplePat> for Pat {
            fn from(n: TuplePat) -> Pat { 
                Pat::TuplePat(n)
            }
        }
        impl From<LiteralPat> for Pat {
            fn from(n: LiteralPat) -> Pat { 
                Pat::LiteralPat(n)
            }
        }
impl AstNode for Pat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | BIND_PAT | PLACEHOLDER_PAT | TUPLE_PAT | LITERAL_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
             
            | BIND_PAT  => Some(Pat::BindPat(BindPat {syntax})), 
            | PLACEHOLDER_PAT  => Some(Pat::PlaceholderPat(PlaceholderPat {syntax})), 
            | TUPLE_PAT  => Some(Pat::TuplePat(TuplePat {syntax})), 
            | LITERAL_PAT  => Some(Pat::LiteralPat(LiteralPat {syntax})),_ => None
        }
    }
    fn syntax(&self) -> &SyntaxNode {  
        match self {
             
                Pat::BindPat(kind)  => &kind.syntax, 
                Pat::PlaceholderPat(kind)  => &kind.syntax, 
                Pat::TuplePat(kind)  => &kind.syntax, 
                Pat::LiteralPat(kind)  => &kind.syntax,}
    
    }
}

impl Pat {}

// PlaceholderPat

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PlaceholderPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PlaceholderPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PLACEHOLDER_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PlaceholderPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PlaceholderPat {}

// PrefixExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PrefixExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PREFIX_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PrefixExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PrefixExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// RecordLiteralExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RecordLiteralExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for RecordLiteralExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RECORD_LITERAL_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(RecordLiteralExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NamedFieldsOwner for RecordLiteralExpr {}
impl RecordLiteralExpr {
    pub fn named_field_list(&self) -> Option<NamedFieldList> {
        child_opt(self)
    }

    pub fn ident(&self) -> Option<IdentExpr> {
        child_opt(self)
    }
}

// RetType

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for RetType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RET_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(RetType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl RetType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// ReturnExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ReturnExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RETURN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ReturnExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ReturnExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// SourceFile

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SOURCE_FILE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(SourceFile { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::ClassDefOwner for SourceFile {}
impl traits::FnDefOwner for SourceFile {}
impl traits::TypeAliasDefOwner for SourceFile {}
impl traits::EnumDefOwner for SourceFile {}
impl traits::ExternImportDefOwner for SourceFile {}
impl traits::ModuleDefOwner for SourceFile {}
impl SourceFile {}

// Stmt


    #[derive(Debug, Clone, PartialEq, Eq,Hash)]
    pub enum Stmt {
            ExprStmt(ExprStmt),
            LetStmt(LetStmt),
    }
        impl From<ExprStmt> for Stmt {
            fn from(n: ExprStmt) -> Stmt { 
                Stmt::ExprStmt(n)
            }
        }
        impl From<LetStmt> for Stmt {
            fn from(n: LetStmt) -> Stmt { 
                Stmt::LetStmt(n)
            }
        }
impl AstNode for Stmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | EXPR_STMT | LET_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
             
            | EXPR_STMT  => Some(Stmt::ExprStmt(ExprStmt {syntax})), 
            | LET_STMT  => Some(Stmt::LetStmt(LetStmt {syntax})),_ => None
        }
    }
    fn syntax(&self) -> &SyntaxNode {  
        match self {
             
                Stmt::ExprStmt(kind)  => &kind.syntax, 
                Stmt::LetStmt(kind)  => &kind.syntax,}
    
    }
}

impl Stmt {}

// TupleExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TupleExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TUPLE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TupleExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TupleExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        children(self)
    }
}

// TuplePat

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TuplePat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TUPLE_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TuplePat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TuplePat {
    pub fn args(&self) -> impl Iterator<Item = Pat> {
        children(self)
    }
}

// TypeAliasDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAliasDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeAliasDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_ALIAS_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeAliasDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for TypeAliasDef {}
impl traits::TypeParamsOwner for TypeAliasDef {}
impl traits::VisibilityOwner for TypeAliasDef {}
impl TypeAliasDef {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// TypeArgList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArgList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeArgList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_ARG_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeArgList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TypeArgList {
    pub fn types(&self) -> impl Iterator<Item = TypeRef> {
        children(self)
    }
}

// TypeParam

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_PARAM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeParam { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for TypeParam {}
impl TypeParam {}

// TypeParamList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParamList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeParamList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_PARAM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeParamList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TypeParamList {
    pub fn type_params(&self) -> impl Iterator<Item = TypeParam> {
        children(self)
    }
}

// TypeRef


    #[derive(Debug, Clone, PartialEq, Eq,Hash)]
    pub enum TypeRef {
            ParenType(ParenType),
            ArrayType(ArrayType),
            FnType(FnType),
            IdentType(IdentType),
    }
        impl From<ParenType> for TypeRef {
            fn from(n: ParenType) -> TypeRef { 
                TypeRef::ParenType(n)
            }
        }
        impl From<ArrayType> for TypeRef {
            fn from(n: ArrayType) -> TypeRef { 
                TypeRef::ArrayType(n)
            }
        }
        impl From<FnType> for TypeRef {
            fn from(n: FnType) -> TypeRef { 
                TypeRef::FnType(n)
            }
        }
        impl From<IdentType> for TypeRef {
            fn from(n: IdentType) -> TypeRef { 
                TypeRef::IdentType(n)
            }
        }
impl AstNode for TypeRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | PAREN_TYPE | ARRAY_TYPE | FN_TYPE | IDENT_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        match syntax.kind() {
             
            | PAREN_TYPE  => Some(TypeRef::ParenType(ParenType {syntax})), 
            | ARRAY_TYPE  => Some(TypeRef::ArrayType(ArrayType {syntax})), 
            | FN_TYPE  => Some(TypeRef::FnType(FnType {syntax})), 
            | IDENT_TYPE  => Some(TypeRef::IdentType(IdentType {syntax})),_ => None
        }
    }
    fn syntax(&self) -> &SyntaxNode {  
        match self {
             
                TypeRef::ParenType(kind)  => &kind.syntax, 
                TypeRef::ArrayType(kind)  => &kind.syntax, 
                TypeRef::FnType(kind)  => &kind.syntax, 
                TypeRef::IdentType(kind)  => &kind.syntax,}
    
    }
}

impl TypeRef {}

// Visibility

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Visibility {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Visibility {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            VISIBILITY => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Visibility { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Visibility {}

// WhileExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for WhileExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            WHILE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(WhileExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::LoopBodyOwner for WhileExpr {}
impl WhileExpr {
    pub fn condition(&self) -> Option<Condition> {
        child_opt(self)
    }
}

