
// This file is automatically generated based on the file `./generated.rs.tera` when `hawthorn::generate` is run
// Do not edit manually

//! This module contains auto-generated Rust AST. Like `SyntaxNode`s, AST nodes
//! are generic over ownership: `X<'a>` things are `Copy` references, `XNode`
//! are Arc-based. You can switch between the two variants using `.owned` and
//! `.borrowed` functions. Most of the code works with borowed mode, and only
//! this mode has all AST accessors.
#![allow(bad_style, missing_docs, unreachable_pub)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use crate::traits::{AstNode,self,child_opt,children};
use crate::SyntaxNode;
use SyntaxKind::*;
/// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.
#[derive(Debug,Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u16)]
pub enum SyntaxKind {
    // Technical SyntaxKinds: they appear temporally during parsing,
    // but never end up in the final tree
    #[doc(hidden)]
    EOF,
    SEMI, // ;
    COMMA, // ,
    L_PAREN, // (
    R_PAREN, // )
    L_CURLY, // {
    R_CURLY, // }
    L_BRACK, // [
    R_BRACK, // ]
    L_ANGLE, // <
    R_ANGLE, // >
    AMP, // &
    PIPE, // |
    PLUS, // +
    STAR, // *
    SLASH, // /
    CARET, // ^
    PERCENT, // %
    UNDERSCORE, // _
    EXPONENTIAL, // ^
    DOT, // .
    QUESTION, // ?
    MINUS, // -
    FRETURN, // ->
    COLON, // :
    COLON_COLON, // ::
    EQ, // =
    EQEQ, // ==
    FAT_ARROW, // =>
    EXCL, // !
    NEQ, // !=
    LTEQ, // <=
    GTEQ, // >=
    PLUSEQ, // +=
    MINUSEQ, // -=
    STAREQ, // *=
    SLASHEQ, // /=
    AMPAMP, // &&
    PIPEPIPE, // ||
    CLASS_KW, // class
    EXTENDS_KW, // extends
    TYPE_KW, // type
    AS_KW, // as
    MATCH_KW, // match
    ENUM_KW, // enum
    FN_KW, // fn
    LET_KW, // let
    IF_KW, // if
    ELSE_KW, // else
    FOR_KW, // for
    WHILE_KW, // while
    RETURN_KW, // return
    BREAK_KW, // break
    CONTINUE_KW, // continue
    DO_KW, // do
    TRUE_KW, // true
    FALSE_KW, // false
    OR_KW, // or
    AND_KW, // and
    EXPORT_KW, // export
    IMPORT_KW, // import
    FROM_KW, // from
    PRINT_KW, // print
    NIL_KW, // nil
    SELF_KW, // self
    INT_NUMBER,
    FLOAT_NUMBER,
    CHAR,
    STRING,
    ERROR,
    IDENT,
    COMMENT,
    WHITESPACE,
    BLOCK,
    SOURCE_FILE,
    CLASS_DEF,
    ENUM_DEF,
    FN_DEF,
    EXTERN_IMPORT_DEF,
    TYPE_ALIAS_DEF,
    BIND_PAT,
    PLACEHOLDER_PAT,
    TUPLE_PAT,
    LITERAL_PAT,
    TYPE_REF,
    FN_TYPE,
    PAREN_TYPE,
    ARRAY_TYPE,
    IDENT_TYPE,
    RET_TYPE,
    ARRAY_EXPR,
    CALL_EXPR,
    CAST_EXPR,
    INDEX_EXPR,
    FIELD_EXPR,
    BIN_EXPR,
    PREFIX_EXPR,
    TUPLE_EXPR,
    IF_EXPR,
    WHILE_EXPR,
    CONDITION,
    LOOP_EXPR,
    DO_EXPR,
    FOR_EXPR,
    CONTINUE_EXPR,
    BREAK_EXPR,
    BLOCK_EXPR,
    RETURN_EXPR,
    CLOSURE_EXPR,
    PAREN_EXPR,
    MATCH_EXPR,
    MATCH_ARM_LIST,
    MATCH_ARM,
    MATCH_GUARD,
    CLASS_LIT,
    NAMED_FIELD_LIST,
    NAMED_FIELD,
    ENUM_VARIANT,
    NAMED_FIELD_DEF_LIST,
    NAMED_FIELD_DEF,
    POS_FIELD_DEF_LIST,
    POS_FIELD_DEF,
    ENUM_VARIANT_LIST,
    VISIBILITY,
    LITERAL,
    NAME,
    NAME_REF,
    LET_STMT,
    EXPR_STMT,
    TYPE_PARAM_LIST,
    TYPE_PARAM,
    PARAM_LIST,
    PARAM,
    SELF_PARAM,
    ARG_LIST,
    // Technical kind so that we can cast from u16 safely
    #[doc(hidden)]
    __LAST,
}


impl From<SyntaxKind> for rowan::cursor::SyntaxKind {
    fn from(kind: SyntaxKind) -> Self {
        Self(kind as u16)
    }
}


impl SyntaxKind {
    pub fn text(&self) -> &'static str {
        use SyntaxKind::*;
        match self {
            SEMI => ";",
            COMMA => ",",
            L_PAREN => "(",
            R_PAREN => ")",
            L_CURLY => "{",
            R_CURLY => "}",
            L_BRACK => "[",
            R_BRACK => "]",
            L_ANGLE => "<",
            R_ANGLE => ">",
            AMP => "&",
            PIPE => "|",
            PLUS => "+",
            STAR => "*",
            SLASH => "/",
            CARET => "^",
            PERCENT => "%",
            UNDERSCORE => "_",
            EXPONENTIAL => "^",
            DOT => ".",
            QUESTION => "?",
            MINUS => "-",
            FRETURN => "->",
            COLON => ":",
            COLON_COLON => "::",
            EQ => "=",
            EQEQ => "==",
            FAT_ARROW => "=>",
            EXCL => "!",
            NEQ => "!=",
            LTEQ => "<=",
            GTEQ => ">=",
            PLUSEQ => "+=",
            MINUSEQ => "-=",
            STAREQ => "*=",
            SLASHEQ => "/=",
            AMPAMP => "&&",
            PIPEPIPE => "||",
            CLASS_KW => "class",
            EXTENDS_KW => "extends",
            TYPE_KW => "type",
            AS_KW => "as",
            MATCH_KW => "match",
            ENUM_KW => "enum",
            FN_KW => "fn",
            LET_KW => "let",
            IF_KW => "if",
            ELSE_KW => "else",
            FOR_KW => "for",
            WHILE_KW => "while",
            RETURN_KW => "return",
            BREAK_KW => "break",
            CONTINUE_KW => "continue",
            DO_KW => "do",
            TRUE_KW => "true",
            FALSE_KW => "false",
            OR_KW => "or",
            AND_KW => "and",
            EXPORT_KW => "export",
            IMPORT_KW => "import",
            FROM_KW => "from",
            PRINT_KW => "print",
            NIL_KW => "nil",
            SELF_KW => "self",
            INT_NUMBER => "INT_NUMBER",
            FLOAT_NUMBER => "FLOAT_NUMBER",
            CHAR => "CHAR",
            STRING => "STRING",
            ERROR => "ERROR",
            IDENT => "IDENT",
            COMMENT => "COMMENT",
            WHITESPACE => "WHITESPACE",
            BLOCK => "BLOCK",
            SOURCE_FILE => "SOURCE_FILE",
            CLASS_DEF => "CLASS_DEF",
            ENUM_DEF => "ENUM_DEF",
            FN_DEF => "FN_DEF",
            EXTERN_IMPORT_DEF => "EXTERN_IMPORT_DEF",
            TYPE_ALIAS_DEF => "TYPE_ALIAS_DEF",
            BIND_PAT => "BIND_PAT",
            PLACEHOLDER_PAT => "PLACEHOLDER_PAT",
            TUPLE_PAT => "TUPLE_PAT",
            LITERAL_PAT => "LITERAL_PAT",
            TYPE_REF => "TYPE_REF",
            FN_TYPE => "FN_TYPE",
            PAREN_TYPE => "PAREN_TYPE",
            ARRAY_TYPE => "ARRAY_TYPE",
            IDENT_TYPE => "IDENT_TYPE",
            RET_TYPE => "RET_TYPE",
            ARRAY_EXPR => "ARRAY_EXPR",
            CALL_EXPR => "CALL_EXPR",
            CAST_EXPR => "CAST_EXPR",
            INDEX_EXPR => "INDEX_EXPR",
            FIELD_EXPR => "FIELD_EXPR",
            BIN_EXPR => "BIN_EXPR",
            PREFIX_EXPR => "PREFIX_EXPR",
            TUPLE_EXPR => "TUPLE_EXPR",
            IF_EXPR => "IF_EXPR",
            WHILE_EXPR => "WHILE_EXPR",
            CONDITION => "CONDITION",
            LOOP_EXPR => "LOOP_EXPR",
            DO_EXPR => "DO_EXPR",
            FOR_EXPR => "FOR_EXPR",
            CONTINUE_EXPR => "CONTINUE_EXPR",
            BREAK_EXPR => "BREAK_EXPR",
            BLOCK_EXPR => "BLOCK_EXPR",
            RETURN_EXPR => "RETURN_EXPR",
            CLOSURE_EXPR => "CLOSURE_EXPR",
            PAREN_EXPR => "PAREN_EXPR",
            MATCH_EXPR => "MATCH_EXPR",
            MATCH_ARM_LIST => "MATCH_ARM_LIST",
            MATCH_ARM => "MATCH_ARM",
            MATCH_GUARD => "MATCH_GUARD",
            CLASS_LIT => "CLASS_LIT",
            NAMED_FIELD_LIST => "NAMED_FIELD_LIST",
            NAMED_FIELD => "NAMED_FIELD",
            ENUM_VARIANT => "ENUM_VARIANT",
            NAMED_FIELD_DEF_LIST => "NAMED_FIELD_DEF_LIST",
            NAMED_FIELD_DEF => "NAMED_FIELD_DEF",
            POS_FIELD_DEF_LIST => "POS_FIELD_DEF_LIST",
            POS_FIELD_DEF => "POS_FIELD_DEF",
            ENUM_VARIANT_LIST => "ENUM_VARIANT_LIST",
            VISIBILITY => "VISIBILITY",
            LITERAL => "LITERAL",
            NAME => "NAME",
            NAME_REF => "NAME_REF",
            LET_STMT => "LET_STMT",
            EXPR_STMT => "EXPR_STMT",
            TYPE_PARAM_LIST => "TYPE_PARAM_LIST",
            TYPE_PARAM => "TYPE_PARAM",
            PARAM_LIST => "PARAM_LIST",
            PARAM => "PARAM",
            SELF_PARAM => "SELF_PARAM",
            ARG_LIST => "ARG_LIST",
        
            _ => ""
        }
    }
}


// ArgList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArgList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARG_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArgList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArgList {
    pub fn args(&self) -> impl Iterator<Item = Expr> {
        children(self)
    }
}

// ArrayExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArrayExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARRAY_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArrayExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArrayExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        children(self)
    }
}

// ArrayType

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ArrayType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ARRAY_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ArrayType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ArrayType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// BinExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BinExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BIN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BinExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BinExpr {}

// BindPat

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BindPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BindPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BIND_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BindPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for BindPat {}
impl BindPat {}

// Block

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Block {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BLOCK => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Block { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Block {
    pub fn statements(&self) -> impl Iterator<Item = Stmt> {
        children(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// BlockExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BlockExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BLOCK_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BlockExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BlockExpr {
    pub fn block(&self) -> Option<Block> {
        child_opt(self)
    }
}

// BreakExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for BreakExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BREAK_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(BreakExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl BreakExpr {}

// CallExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for CallExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CALL_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(CallExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::ArgListOwner for CallExpr {}
impl CallExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// CastExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for CastExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CAST_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(CastExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl CastExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// ClassDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ClassDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CLASS_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ClassDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for ClassDef {}
impl traits::TypeParamsOwner for ClassDef {}
impl traits::FnDefOwner for ClassDef {}
impl traits::NamedFieldsOwner for ClassDef {}
impl ClassDef {}

// ClassLit

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassLit {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ClassLit {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CLASS_LIT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ClassLit { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ClassLit {
    pub fn named_field_list(&self) -> Option<NamedFieldList> {
        child_opt(self)
    }
}

// ClosureExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClosureExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ClosureExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CLOSURE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ClosureExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ClosureExpr {
    pub fn param_list(&self) -> Option<ParamList> {
        child_opt(self)
    }

    pub fn body(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// Condition

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Condition {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Condition {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CONDITION => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Condition { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Condition {
    pub fn pat(&self) -> Option<Pat> {
        child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// ContinueExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ContinueExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            CONTINUE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ContinueExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ContinueExpr {}

// EnumDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for EnumDef {}
impl EnumDef {
    pub fn variant_list(&self) -> Option<EnumVariantList> {
        child_opt(self)
    }
}

// EnumVariant

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariant {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumVariant {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_VARIANT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumVariant { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for EnumVariant {}
impl EnumVariant {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// EnumVariantList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumVariantList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for EnumVariantList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ENUM_VARIANT_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(EnumVariantList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl EnumVariantList {
    pub fn variants(&self) -> impl Iterator<Item = EnumVariant> {
        children(self)
    }
}

// Expr


    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum Expr {
            ArrayExpr(ArrayExpr),
            ParenExpr(ParenExpr),
            ClosureExpr(ClosureExpr),
            IfExpr(IfExpr),
            ForExpr(ForExpr),
            WhileExpr(WhileExpr),
            ContinueExpr(ContinueExpr),
            BreakExpr(BreakExpr),
            BlockExpr(BlockExpr),
            ReturnExpr(ReturnExpr),
            MatchExpr(MatchExpr),
            ClassLit(ClassLit),
            CallExpr(CallExpr),
            IndexExpr(IndexExpr),
            FieldExpr(FieldExpr),
            CastExpr(CastExpr),
            PrefixExpr(PrefixExpr),
            BinExpr(BinExpr),
            Literal(Literal),
    }
        impl From<ArrayExpr> for Expr {
            fn from(n: ArrayExpr) -> Expr { 
                Expr::ArrayExpr(n)
            }
        }
        impl From<ParenExpr> for Expr {
            fn from(n: ParenExpr) -> Expr { 
                Expr::ParenExpr(n)
            }
        }
        impl From<ClosureExpr> for Expr {
            fn from(n: ClosureExpr) -> Expr { 
                Expr::ClosureExpr(n)
            }
        }
        impl From<IfExpr> for Expr {
            fn from(n: IfExpr) -> Expr { 
                Expr::IfExpr(n)
            }
        }
        impl From<ForExpr> for Expr {
            fn from(n: ForExpr) -> Expr { 
                Expr::ForExpr(n)
            }
        }
        impl From<WhileExpr> for Expr {
            fn from(n: WhileExpr) -> Expr { 
                Expr::WhileExpr(n)
            }
        }
        impl From<ContinueExpr> for Expr {
            fn from(n: ContinueExpr) -> Expr { 
                Expr::ContinueExpr(n)
            }
        }
        impl From<BreakExpr> for Expr {
            fn from(n: BreakExpr) -> Expr { 
                Expr::BreakExpr(n)
            }
        }
        impl From<BlockExpr> for Expr {
            fn from(n: BlockExpr) -> Expr { 
                Expr::BlockExpr(n)
            }
        }
        impl From<ReturnExpr> for Expr {
            fn from(n: ReturnExpr) -> Expr { 
                Expr::ReturnExpr(n)
            }
        }
        impl From<MatchExpr> for Expr {
            fn from(n: MatchExpr) -> Expr { 
                Expr::MatchExpr(n)
            }
        }
        impl From<ClassLit> for Expr {
            fn from(n: ClassLit) -> Expr { 
                Expr::ClassLit(n)
            }
        }
        impl From<CallExpr> for Expr {
            fn from(n: CallExpr) -> Expr { 
                Expr::CallExpr(n)
            }
        }
        impl From<IndexExpr> for Expr {
            fn from(n: IndexExpr) -> Expr { 
                Expr::IndexExpr(n)
            }
        }
        impl From<FieldExpr> for Expr {
            fn from(n: FieldExpr) -> Expr { 
                Expr::FieldExpr(n)
            }
        }
        impl From<CastExpr> for Expr {
            fn from(n: CastExpr) -> Expr { 
                Expr::CastExpr(n)
            }
        }
        impl From<PrefixExpr> for Expr {
            fn from(n: PrefixExpr) -> Expr { 
                Expr::PrefixExpr(n)
            }
        }
        impl From<BinExpr> for Expr {
            fn from(n: BinExpr) -> Expr { 
                Expr::BinExpr(n)
            }
        }
        impl From<Literal> for Expr {
            fn from(n: Literal) -> Expr { 
                Expr::Literal(n)
            }
        }
impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | ARRAY_EXPR | PAREN_EXPR | CLOSURE_EXPR | IF_EXPR | FOR_EXPR | WHILE_EXPR | CONTINUE_EXPR | BREAK_EXPR | BLOCK_EXPR | RETURN_EXPR | MATCH_EXPR | CLASS_LIT | CALL_EXPR | INDEX_EXPR | FIELD_EXPR | CAST_EXPR | PREFIX_EXPR | BIN_EXPR | LITERAL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        return match syntax.kind() {
             
            | ARRAY_EXPR  => Some(Expr::ArrayExpr(ArrayExpr {syntax})), 
            | PAREN_EXPR  => Some(Expr::ParenExpr(ParenExpr {syntax})), 
            | CLOSURE_EXPR  => Some(Expr::ClosureExpr(ClosureExpr {syntax})), 
            | IF_EXPR  => Some(Expr::IfExpr(IfExpr {syntax})), 
            | FOR_EXPR  => Some(Expr::ForExpr(ForExpr {syntax})), 
            | WHILE_EXPR  => Some(Expr::WhileExpr(WhileExpr {syntax})), 
            | CONTINUE_EXPR  => Some(Expr::ContinueExpr(ContinueExpr {syntax})), 
            | BREAK_EXPR  => Some(Expr::BreakExpr(BreakExpr {syntax})), 
            | BLOCK_EXPR  => Some(Expr::BlockExpr(BlockExpr {syntax})), 
            | RETURN_EXPR  => Some(Expr::ReturnExpr(ReturnExpr {syntax})), 
            | MATCH_EXPR  => Some(Expr::MatchExpr(MatchExpr {syntax})), 
            | CLASS_LIT  => Some(Expr::ClassLit(ClassLit {syntax})), 
            | CALL_EXPR  => Some(Expr::CallExpr(CallExpr {syntax})), 
            | INDEX_EXPR  => Some(Expr::IndexExpr(IndexExpr {syntax})), 
            | FIELD_EXPR  => Some(Expr::FieldExpr(FieldExpr {syntax})), 
            | CAST_EXPR  => Some(Expr::CastExpr(CastExpr {syntax})), 
            | PREFIX_EXPR  => Some(Expr::PrefixExpr(PrefixExpr {syntax})), 
            | BIN_EXPR  => Some(Expr::BinExpr(BinExpr {syntax})), 
            | LITERAL  => Some(Expr::Literal(Literal {syntax})),_ => None
        }
    }
    fn syntax(&self) -> &SyntaxNode {  
        match self {
             
                Expr::ArrayExpr(kind)  => &kind.syntax, 
                Expr::ParenExpr(kind)  => &kind.syntax, 
                Expr::ClosureExpr(kind)  => &kind.syntax, 
                Expr::IfExpr(kind)  => &kind.syntax, 
                Expr::ForExpr(kind)  => &kind.syntax, 
                Expr::WhileExpr(kind)  => &kind.syntax, 
                Expr::ContinueExpr(kind)  => &kind.syntax, 
                Expr::BreakExpr(kind)  => &kind.syntax, 
                Expr::BlockExpr(kind)  => &kind.syntax, 
                Expr::ReturnExpr(kind)  => &kind.syntax, 
                Expr::MatchExpr(kind)  => &kind.syntax, 
                Expr::ClassLit(kind)  => &kind.syntax, 
                Expr::CallExpr(kind)  => &kind.syntax, 
                Expr::IndexExpr(kind)  => &kind.syntax, 
                Expr::FieldExpr(kind)  => &kind.syntax, 
                Expr::CastExpr(kind)  => &kind.syntax, 
                Expr::PrefixExpr(kind)  => &kind.syntax, 
                Expr::BinExpr(kind)  => &kind.syntax, 
                Expr::Literal(kind)  => &kind.syntax,}
    
    }
}

impl Expr {}

// ExprStmt

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ExprStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            EXPR_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ExprStmt { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ExprStmt {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// ExternImportDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExternImportDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ExternImportDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            EXTERN_IMPORT_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ExternImportDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ExternImportDef {
    pub fn imports(&self) -> Option<Name> {
        child_opt(self)
    }
}

// FieldExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FieldExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FIELD_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FieldExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl FieldExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn name_ref(&self) -> Option<NameRef> {
        child_opt(self)
    }
}

// FnDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FnDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FN_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FnDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for FnDef {}
impl traits::TypeParamsOwner for FnDef {}
impl traits::VisibilityOwner for FnDef {}
impl FnDef {
    pub fn param_list(&self) -> Option<ParamList> {
        child_opt(self)
    }

    pub fn body(&self) -> Option<Block> {
        child_opt(self)
    }

    pub fn ret_type(&self) -> Option<RetType> {
        child_opt(self)
    }
}

// FnType

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for FnType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FN_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(FnType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypesOwner for FnType {}
impl FnType {
    pub fn param_list(&self) -> Option<ParamList> {
        child_opt(self)
    }

    pub fn ret_type(&self) -> Option<RetType> {
        child_opt(self)
    }
}

// ForExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ForExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            FOR_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ForExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::LoopBodyOwner for ForExpr {}
impl ForExpr {
    pub fn init(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn cond(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn increment(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// IdentType

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IdentType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IDENT_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IdentType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IdentType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// IfExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IfExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            IF_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IfExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IfExpr {
    pub fn condition(&self) -> Option<Condition> {
        child_opt(self)
    }
}

// IndexExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for IndexExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            INDEX_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(IndexExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl IndexExpr {}

// LetStmt

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LetStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LET_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LetStmt { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypeAscriptionOwner for LetStmt {}
impl LetStmt {
    pub fn pat(&self) -> Option<Pat> {
        child_opt(self)
    }

    pub fn initializer(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// Literal

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LITERAL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Literal { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Literal {}

// LiteralPat

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for LiteralPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            LITERAL_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(LiteralPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl LiteralPat {
    pub fn literal(&self) -> Option<Literal> {
        child_opt(self)
    }
}

// MatchArm

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_ARM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchArm { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchArm {
    pub fn pats(&self) -> impl Iterator<Item = Pat> {
        children(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// MatchArmList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArmList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchArmList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_ARM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchArmList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchArmList {
    pub fn arms(&self) -> impl Iterator<Item = MatchArm> {
        children(self)
    }
}

// MatchExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for MatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            MATCH_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(MatchExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl MatchExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }

    pub fn match_arm_list(&self) -> Option<MatchArmList> {
        child_opt(self)
    }
}

// Name

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAME => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Name { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Name {}

// NameRef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NameRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAME_REF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NameRef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NameRef {}

// NamedField

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedField {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedField {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedField { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedField {
    pub fn name_ref(&self) -> Option<NameRef> {
        child_opt(self)
    }

    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// NamedFieldDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for NamedFieldDef {}
impl traits::TypeAscriptionOwner for NamedFieldDef {}
impl NamedFieldDef {}

// NamedFieldDefList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldDefList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldDefList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_DEF_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldDefList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedFieldDefList {
    pub fn fields(&self) -> impl Iterator<Item = NamedFieldDef> {
        children(self)
    }
}

// NamedFieldList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for NamedFieldList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            NAMED_FIELD_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(NamedFieldList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl NamedFieldList {
    pub fn fields(&self) -> impl Iterator<Item = NamedField> {
        children(self)
    }
}

// Param

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Param {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PARAM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Param { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypeAscriptionOwner for Param {}
impl Param {
    pub fn pat(&self) -> Option<Pat> {
        child_opt(self)
    }
}

// ParamList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParamList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PARAM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParamList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ParamList {
    pub fn params(&self) -> impl Iterator<Item = Param> {
        children(self)
    }
}

// ParenExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParenExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PAREN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParenExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ParenExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// ParenType

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ParenType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PAREN_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ParenType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypesOwner for ParenType {}
impl ParenType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// Pat


    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum Pat {
            BindPat(BindPat),
            PlaceholderPat(PlaceholderPat),
            TuplePat(TuplePat),
            LiteralPat(LiteralPat),
    }
        impl From<BindPat> for Pat {
            fn from(n: BindPat) -> Pat { 
                Pat::BindPat(n)
            }
        }
        impl From<PlaceholderPat> for Pat {
            fn from(n: PlaceholderPat) -> Pat { 
                Pat::PlaceholderPat(n)
            }
        }
        impl From<TuplePat> for Pat {
            fn from(n: TuplePat) -> Pat { 
                Pat::TuplePat(n)
            }
        }
        impl From<LiteralPat> for Pat {
            fn from(n: LiteralPat) -> Pat { 
                Pat::LiteralPat(n)
            }
        }
impl AstNode for Pat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | BIND_PAT | PLACEHOLDER_PAT | TUPLE_PAT | LITERAL_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        return match syntax.kind() {
             
            | BIND_PAT  => Some(Pat::BindPat(BindPat {syntax})), 
            | PLACEHOLDER_PAT  => Some(Pat::PlaceholderPat(PlaceholderPat {syntax})), 
            | TUPLE_PAT  => Some(Pat::TuplePat(TuplePat {syntax})), 
            | LITERAL_PAT  => Some(Pat::LiteralPat(LiteralPat {syntax})),_ => None
        }
    }
    fn syntax(&self) -> &SyntaxNode {  
        match self {
             
                Pat::BindPat(kind)  => &kind.syntax, 
                Pat::PlaceholderPat(kind)  => &kind.syntax, 
                Pat::TuplePat(kind)  => &kind.syntax, 
                Pat::LiteralPat(kind)  => &kind.syntax,}
    
    }
}

impl Pat {}

// PlaceholderPat

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PlaceholderPat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PlaceholderPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PLACEHOLDER_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PlaceholderPat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PlaceholderPat {}

// PrefixExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for PrefixExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PREFIX_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(PrefixExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl PrefixExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// RetType

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for RetType {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RET_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(RetType { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl RetType {
    pub fn type_ref(&self) -> Option<TypeRef> {
        child_opt(self)
    }
}

// ReturnExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for ReturnExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            RETURN_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(ReturnExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl ReturnExpr {
    pub fn expr(&self) -> Option<Expr> {
        child_opt(self)
    }
}

// SourceFile

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            SOURCE_FILE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(SourceFile { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::ClassDefOwner for SourceFile {}
impl traits::FnDefOwner for SourceFile {}
impl traits::TypeAliasDefOwner for SourceFile {}
impl traits::EnumDefOwner for SourceFile {}
impl traits::ExternImportDefOwner for SourceFile {}
impl SourceFile {}

// Stmt


    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum Stmt {
            ExprStmt(ExprStmt),
            LetStmt(LetStmt),
    }
        impl From<ExprStmt> for Stmt {
            fn from(n: ExprStmt) -> Stmt { 
                Stmt::ExprStmt(n)
            }
        }
        impl From<LetStmt> for Stmt {
            fn from(n: LetStmt) -> Stmt { 
                Stmt::LetStmt(n)
            }
        }
impl AstNode for Stmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | EXPR_STMT | LET_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        return match syntax.kind() {
             
            | EXPR_STMT  => Some(Stmt::ExprStmt(ExprStmt {syntax})), 
            | LET_STMT  => Some(Stmt::LetStmt(LetStmt {syntax})),_ => None
        }
    }
    fn syntax(&self) -> &SyntaxNode {  
        match self {
             
                Stmt::ExprStmt(kind)  => &kind.syntax, 
                Stmt::LetStmt(kind)  => &kind.syntax,}
    
    }
}

impl Stmt {}

// TuplePat

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TuplePat {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TUPLE_PAT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TuplePat { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TuplePat {
    pub fn args(&self) -> impl Iterator<Item = Pat> {
        children(self)
    }
}

// TypeAliasDef

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAliasDef {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeAliasDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_ALIAS_DEF => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeAliasDef { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::TypeParamsOwner for TypeAliasDef {}
impl TypeAliasDef {}

// TypeParam

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_PARAM => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeParam { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::NameOwner for TypeParam {}
impl TypeParam {}

// TypeParamList

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParamList {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for TypeParamList {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            TYPE_PARAM_LIST => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(TypeParamList { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl TypeParamList {
    pub fn type_params(&self) -> impl Iterator<Item = TypeParam> {
        children(self)
    }
}

// TypeRef


    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum TypeRef {
            ParenType(ParenType),
            ArrayType(ArrayType),
            FnType(FnType),
            IdentType(IdentType),
    }
        impl From<ParenType> for TypeRef {
            fn from(n: ParenType) -> TypeRef { 
                TypeRef::ParenType(n)
            }
        }
        impl From<ArrayType> for TypeRef {
            fn from(n: ArrayType) -> TypeRef { 
                TypeRef::ArrayType(n)
            }
        }
        impl From<FnType> for TypeRef {
            fn from(n: FnType) -> TypeRef { 
                TypeRef::FnType(n)
            }
        }
        impl From<IdentType> for TypeRef {
            fn from(n: IdentType) -> TypeRef { 
                TypeRef::IdentType(n)
            }
        }
impl AstNode for TypeRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
             | PAREN_TYPE | ARRAY_TYPE | FN_TYPE | IDENT_TYPE => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        return match syntax.kind() {
             
            | PAREN_TYPE  => Some(TypeRef::ParenType(ParenType {syntax})), 
            | ARRAY_TYPE  => Some(TypeRef::ArrayType(ArrayType {syntax})), 
            | FN_TYPE  => Some(TypeRef::FnType(FnType {syntax})), 
            | IDENT_TYPE  => Some(TypeRef::IdentType(IdentType {syntax})),_ => None
        }
    }
    fn syntax(&self) -> &SyntaxNode {  
        match self {
             
                TypeRef::ParenType(kind)  => &kind.syntax, 
                TypeRef::ArrayType(kind)  => &kind.syntax, 
                TypeRef::FnType(kind)  => &kind.syntax, 
                TypeRef::IdentType(kind)  => &kind.syntax,}
    
    }
}

impl TypeRef {}

// Visibility

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Visibility {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for Visibility {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            VISIBILITY => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Visibility { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl Visibility {}

// WhileExpr

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub(crate) syntax: SyntaxNode,
}

impl AstNode for WhileExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            WHILE_EXPR => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(WhileExpr { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}


impl traits::LoopBodyOwner for WhileExpr {}
impl WhileExpr {
    pub fn condition(&self) -> Option<Condition> {
        child_opt(self)
    }
}

